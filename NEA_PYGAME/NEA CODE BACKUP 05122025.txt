import random, pygame, math, time, heapq

#---CLASSES---#

class Queue:
   def __init__(self):
       self.Queue = []
       self.Counter = 0

   def enqueue(self, Element, Priority):
       heapq.heappush(self.Queue, (Priority, self.Counter, Element))
       self.Counter +=1 

   def dequeue(self):
       return heapq.heappop(self.Queue)[2]

   def peek(self):
       if self.isEmpty():
           return "Queue is empty"
       return self.Queue[0]

   def Megapeek(self):
       if self.isEmpty():
           return "Queue is empty"
       return self.Queue

   def isEmpty(self):
       return len(self.Queue) == 0

   def size(self):
       return len(self.Queue)

   def display(self):
       print(self.Queue)

   def Destroy(self):
       self.Queue.clear()
       self.Counter = 0

class Cell:
   def __init__(self):
       self.Weight = int(0)
       self.Coordinates = ()
       self.Previousvertex = 0
       self.ObjType = None

   def SetCoordinates(self, Tup):
       self.Coordinates = (Tup)

   def SetWeight(self, W):
       self.Weight = int(W)

   def SetPreviousVertex(self, Vertex):
       self.Previousvertex = Vertex

   def SetType(self, NewType):
       self.ObjType = NewType

   def GetCoordinates(self):
       return self.Coordinates

   def GetPosition(self):
       return ConvertNumCoord(self.Coordinates, 0)

   def GetWeight(self):
       return self.Weight #The cell object that gets put into a grd of width x height

   def GetType(self):
       return self.ObjType

   def GetPrevious(self):
       return self.Previousvertex

#--INITIALISE ALL GRIDS, BOARDS, DICTIONARIES--#

WIDTH = 60 #Change based on grid size
HEIGHT = 30

AREA = WIDTH*HEIGHT

#Box scales
SQUAREWIDTH = 20
SQUAREHEIGHT = 20

OFFSET = 3 # distance between "Pixels" AKA border thickness

#Resolutions
ScreenWIDTH = WIDTH * (SQUAREWIDTH+OFFSET)
ScreenHEIGHT = HEIGHT * (SQUAREHEIGHT+OFFSET)

#Colours
BGCOLOUR = (80, 36, 25)
PIXELCOLOUR = (180, 134, 159)
STARTCOLOUR = (44, 81, 76)
DESTINATION = (44, 81, 76)
PATH = (152, 95, 111)
WALL = (128, 128, 128)

Graph = {} # Graph variable, stored as num of box (1-range): [num of neighbour box (1-range), weight of relationship]
PathWeights = {} #How far is each node from the root

DJQ = Queue() #Create a queue

DisplayBoard = []
Board = [] # Virtual board variable
Visited = [] #Array containing order visited by algorithm
Path = [] #Array that shows the nodes visited to get from one point to root

pygame.init()

#--CONVERSIONS AND MAINTENENCE--#

def ConvertNumCoord(Coord, Choice): #Convert between 1-100 (for example) to (x,y)
   if Choice == 0: #Coord to num
       return (Coord[0] + ((Coord[1]-1) * WIDTH))
   elif Choice == 1: #num to coord
       return (((Coord-1)%WIDTH) + 1,((Coord-1)//WIDTH) + 1)

def ConvertMouseToBox(Mouse_Position):
    XPos, YPos = Mouse_Position

    BlockWidth = ScreenWIDTH / WIDTH
    BlockHeight = ScreenHEIGHT / HEIGHT

    GridX = int(XPos // BlockWidth) + 1
    GridY = int(YPos // BlockHeight) +1

    if GridX > WIDTH or GridY > HEIGHT:
        return None

    return ConvertNumCoord((GridX, GridY), 0 ) #Convert mouse click to grid number

def SetVars():
    global PathWeights
    global DJQ
    global Visited
    global Path
    global Board
    global Graph

    PathWeights = {}
    Graph = {}

    DJQ.Destroy()

    Visited = []
    Path = []
    Board = []

    for x in range (1,(AREA) + 1):
       Board.append(Cell()) #Initialise all the objects and size for the board
       Board[x-1].SetCoordinates(ConvertNumCoord(x, 1)) #Set each cell to have a coordinate of the current space
       Board[x-1].SetWeight(1) #sets each cell to have a weight of 1 (default)
       Board[x-1].SetType(PIXELCOLOUR) #Sets each cell type to default

    for x in range(1,len(Board)+1):
       Graph.setdefault(x, {}) #Creating dictionary keys for each box

    #for z in range(len(Board)):
        #if Board[z].GetWeight() > 1:
            #Board[z].SetType(WALL) #SET A RANDOM WALL : DELETE

    # loops through each box (1-range) and find the neighbours and the weights
    for x in range(1, len(Board) + 1):
        # Left Neighbour
        if((x-1) >= 1 and x % WIDTH != 1):
            Graph[x][x-1] = Board[(x-1)-1].GetWeight() 

        # Right Neighbour
        if((x+1) <= (AREA) and x % WIDTH != 0):
            # Access neighbor (x+1)
            Graph[x][x+1] = Board[(x+1)-1].GetWeight() 

        # Down Neighbour
        if((x+WIDTH) <= (AREA)):
            # Access neighbor (x+WIDTH)
            Graph[x][x+WIDTH] = Board[(x+WIDTH)-1].GetWeight() 

        # Up Neighbour
        if((x-WIDTH) >= 1):
            # Access neighbor (x-WIDTH)
            Graph[x][x-WIDTH] = Board[(x-WIDTH)-1].GetWeight() 

        # LeftUpDiagonal Neighbour
        if((x-1) >= 1 and x % WIDTH != 1 and (x+WIDTH) <= (AREA)):
            Graph[x][x-1+WIDTH] = Board[(x-1+WIDTH)-1].GetWeight() 

        # RightUpDiagonal Neighbour
        if((x+1) <= (AREA) and x % WIDTH != 0 and (x+WIDTH) <= (AREA)):
            Graph[x][x+1+WIDTH] = Board[(x+1+WIDTH)-1].GetWeight() 

        # LeftDownDiagonal Neighbour
        if((x-1) >= 1 and x % WIDTH != 1 and (x-WIDTH) >= 1):
            Graph[x][x-1-WIDTH] = Board[(x-1-WIDTH)-1].GetWeight() 

        # RightDownDiagonal Neighbour
        if((x+1) <= (AREA) and x % WIDTH != 0 and (x-WIDTH) >= 1):
            Graph[x][x+1-WIDTH] = Board[(x+1-WIDTH)-1].GetWeight()

    for x in range (1,(AREA) + 1):
       PathWeights[x] = math.inf

def ClearPath():
    global PathWeights, DJQ, Visited, Path

    DJQ.Destroy()
    Visited = []
    Path = []

    for x in range(1,(AREA+1)):
        PathWeights[x] = math.inf
        Board[x-1].SetPreviousVertex(0)

    for cell in Board:
        if cell.GetType() != WALL:
            cell.SetWeight(1)
            cell.SetType(PIXELCOLOUR)

def UpdateWeights(Grid_Number):
    global Graph, Board
    Weight = Board[Grid_Number-1].GetWeight()

    for Node in Graph:
        if Grid_Number in Graph[Node]:
            Graph[Node][Grid_Number] = Weight

    for Neighbour in Graph[Grid_Number]:
        Graph[Grid_Number][Neighbour] = Board[Neighbour-1].GetWeight()

#--DIJSKTRAS STUFF--#

def DJ(Cell):
   global Board
   global StartNode
   global PathWeights
   
   Current_Position = Cell.GetPosition()

   if Current_Position not in Graph:
       return
   Neighbours = list(Graph[Current_Position])

   Current_Total_Distance = PathWeights[Current_Position]

   for Neighbour_Position in Neighbours:
       Neighbour_Number = int(Neighbour_Position)
       Neighbour_Index = Neighbour_Number-1
       Neighbour_Cell = Board[Neighbour_Index]

       Distance_To = Graph[Current_Position][Neighbour_Position]
       Revised_Weight = Current_Total_Distance + Distance_To

       if Revised_Weight < PathWeights[Neighbour_Position]:
           PathWeights[Neighbour_Position] = Revised_Weight

           #Neighbour_Cell.SetWeight(Revised_Weight)

           Neighbour_Cell.SetPreviousVertex(Current_Position)

           DJQ.enqueue(Neighbour_Cell, Revised_Weight)

def InitialiseDJ(Root):
    global StartNode
    StartNode = Board[Root-1]
    PathWeights[StartNode.GetPosition()] = 0
    PathWeights[StartNode.GetPosition()] = 0

    DJQ.enqueue(StartNode, 0) #Run algorithm from coord point that gets converted to number

    while not DJQ.isEmpty():
        Current_Node = DJQ.dequeue()
        Current_Position = str(Current_Node.GetPosition())

        if Current_Position in Visited:
            continue

        Visited.append(Current_Position)

        DJ(Current_Node)

def GetPrevious(Node):
    global Path

    Current_cell = Board[int(Node)-1]
    Path.append(Current_cell.GetPosition())
    
    if(Current_cell.GetPrevious() != 0):
        GetPrevious(Current_cell.GetPrevious())

def FindRoute(End, Root):
    global PathWeights
    global Visited
    global DJQ
    global Path

    for cell in Board:
        if cell.GetType() == PATH or cell.GetType() == DESTINATION:
            cell.SetType(PIXELCOLOUR)

    DJQ.Destroy()
    Visited = []
    Path = []
    PathWeights = {}

    for x in range(1, AREA + 1):
        PathWeights[x] = math.inf
        Board[x-1].SetPreviousVertex(0)

    InitialiseDJ(Root) #Start Dijkstras with starting node

    GetPrevious(End) #Get path to start from a position
    print(f"To get from {End} to {Root} you take points: {Path} with weight {PathWeights[End]}")

    if len(Path) > 0:
        Board[int(Path[0])-1].SetType(DESTINATION)
        Board[int(Path[-1])-1].SetType(STARTCOLOUR)
        for x in Path[1:len(Path)-1]:
            Cell_index = int(x)-1
            if Board[Cell_index].GetType() != WALL:
                Board[Cell_index].SetType(PATH)

#--PYGAME WINDOW-#
#Application window set up
Screen = pygame.display.set_mode((ScreenWIDTH,ScreenHEIGHT))
pygame.display.set_caption("NEA")

#Tick speed
Clock = pygame.time.Clock()

#Background set up
Surface_grid = [] #Visual feedback of board
Grid_Colliders = []

#--MAIN CODE--#
SetVars()

Root = None
End = None

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

        if event.type == pygame.MOUSEBUTTONDOWN:
            MousePosition = pygame.mouse.get_pos()
            SelectedCell = ConvertMouseToBox(MousePosition)

            if SelectedCell != None and 1 <= SelectedCell <= len(Board):
                if event.button == 1:
                    ClearPath()

                    Root = SelectedCell
                    End = None

                    Board[SelectedCell-1].SetType(STARTCOLOUR)

                    print(f"Start set at: {Root}")
                elif event.button == 3 and Root != None:
                    End = SelectedCell

                    Board[SelectedCell-1].SetType(DESTINATION)
                    print(f"End set at: {End}")

                    ClearPath()
                    FindRoute(End, Root) #Handles mouse left / right click and boxes

        Keys = pygame.key.get_pressed()
        MousePosition = pygame.mouse.get_pos()
        SelectedCell = ConvertMouseToBox(MousePosition)
        if Keys[pygame.K_w]:
            if SelectedCell != None:
                Current_Cell = Board[SelectedCell-1]
                Current_Cell.SetType(WALL)
                Current_Cell.SetWeight(500)
                UpdateWeights(SelectedCell)
        elif Keys[pygame.K_d]:
            if SelectedCell != None:
                Current_Cell = Board[SelectedCell-1]
                Current_Cell.SetType(PIXELCOLOUR)
                Current_Cell.SetWeight(1)
                UpdateWeights(SelectedCell)


    Screen.fill(BGCOLOUR) #Sets the colour of the background
    for x in range(1,WIDTH+1):
        for y in range(1,HEIGHT+1):
            Cell_Index = ConvertNumCoord((x,y),0)-1
            XPos  = (x-1) * (SQUAREWIDTH+OFFSET)
            YPos  = (y-1) * (SQUAREHEIGHT+OFFSET)
            Colour = Board[Cell_Index].GetType()
            pygame.draw.rect(Screen, Board[Cell_Index].GetType(), (XPos, YPos, SQUAREWIDTH, SQUAREHEIGHT))

    pygame.display.flip()
    Clock.tick(120)
    


pygame.quit()